<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Lunatech's engineer blog]]></title><description><![CDATA[FP, Scala and Java]]></description><link>https://pepite.github.io/hubpress.io</link><generator>RSS for Node</generator><lastBuildDate>Tue, 26 Sep 2017 18:00:03 GMT</lastBuildDate><atom:link href="https://pepite.github.io/hubpress.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Functional Rotterdam-15]]></title><description><![CDATA[<div class="paragraph">
<p>Functional Rotterdam is a meetup held monthly in our Lunatech office about Programming Languages, Scala, Computer programming, Haskell, Functional Programming and Clojure, organized by Vijay Kiran, Team Manager at Lunatech.  Thomas Meijers, Software Engineer at Lunatech, presented Free of Interpretation. The presentation was filmed by Celeste Franco (thanks!!).</p>
</div>
<div class="paragraph">
<p>One of Scala&#8217;s main selling points is its interoperability with Java.</p>
</div>
<div class="paragraph">
<p>However, this double-edged sword can be problematic, once you turned into a "functional programmer fundamentalist". This paradigms can make your program not only less beautiful but also harder to understand and reason about. How can we wrap Java libraries in a way that we can still enjoy all the benefits of pure functional programming?</p>
</div>
<div class="paragraph">
<p>This talk introduces the concept of the Free Monad, a powerful technic to separate parts of your program into data, its interpretation and the execution. As shown in this talk, this separation will give many benefits for testing and reasoning. As a use case we will rebuild a small part of a library created by the speaker, which wraps the OrientDB Java library. At the end of this talk you will be able to apply the concept of the Free Monad to wrap any Java Library into a pure functional one.</p>
</div>]]></description><link>https://pepite.github.io/hubpress.io/2016/12/09/Functional-Rotterdam-15.html</link><guid isPermaLink="true">https://pepite.github.io/hubpress.io/2016/12/09/Functional-Rotterdam-15.html</guid><category><![CDATA[scala]]></category><category><![CDATA[clojure]]></category><category><![CDATA[fp]]></category><pubDate>Fri, 09 Dec 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Play Framework - Beginner Tutorial : How to handle a big json file in play ( more than 22 root variables)]]></title><description><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>It is not a good practice to have such a big json with many root variables. Nevertheless, we might need to call a rest api that will give a json like this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{  "a1": ...,  "a2" : ...,  "a3" : ...,  "a4" : ...,  "a5" : ...,  "a6" : ...,  "a7" : ...,  "a8" : ...,  "a9" : ...,  "a10" : ...,  "a11" : ...,  "a12" : ...,  "a13" : ...,  "a14" : ...,  "a15" : ...,  "a16" : ...,  "a17" : ...,  "a18" : ...,  "a19" : ...,  "a20" : ...,  "a21": ...,  "a22" : ...,  "a23" : ...,  "a24" : ...,  ....}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_first_approach">First approach</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Since scala 2.11 we can have case class with more than 22 fields, so the following compiles.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">case class JsonExample (    a1:String, a2:String, a3:String, a4:String, a5:String, a6:String,    a7:String, a8:String, a9:String, a10:String, a11:String, a12:String,    a13:String, a14:String, a15:String, a16:String, a17:String, a18:String,    a19:String, a20:String, a21:String, a22:String, a23:String, a24:String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>But if we try to use Play <a href="https://www.playframework.com/documentation/2.5.x/ScalaJsonAutomated">JSON automated mapping</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">import play.api.libs.json._implicit val jsonExampleFormat = Json.format[JsonExample]</code></pre>
</div>
</div>
<div class="paragraph">
<p>we get a compiler error</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&lt;console&gt;:16: error: No unapply or unapplySeq function found       implicit val jsonExampleFormat = Json.format[JsonExample]                                                   ^</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead we can use <a href="https://www.playframework.com/documentation/2.5.x/ScalaJsonCombinators">Play-Json extensions</a>(requires play-json &gt;= 2.4)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">import ai.x.play.json.Jsonximplicit val jsonExampleFormat = Jsonx.formatCaseClass[JsonExample]

jsonExampleFormat: play.api.libs.json.Format[JsonExample] = $anon$1@b7f7890</code></pre>
</div>
</div>
<div class="paragraph">
<p>So now we have a Play Json format for a case class with more than 22 fields, and can use it as described in <a href="https://www.playframework.com/documentation/2.5.x/ScalaJsonCombinators">Play Json documentation</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_second_approach">Second approach</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I don’t consider having a case class with so many fields a good solution.</p>
</div>
<div class="paragraph">
<p>A better solution is to organize these fields in “logical” embedded case classes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">case class A (    a1:String, a2:String, a3:String, a4:String,    a5:String, a6:String, a7:String, a8:String)

case class B (    a9:String, a10:String, a11:String, a12:String,    a13:String, a14:String, a15:String, a16:String  )case class C (    a17:String, a18:String, a19:String, a20:String,    a21:String, a22:String, a23:String, a24:String  )case class JsonExample2 (    a : A,    b : B,    c : C  )</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use a “regular” play json format for the embedded case classes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">import play.api.libs.json._implicit val jsonAFormat : Format[A] = Json.format[A]implicit val jsonBFormat : Format[B]= Json.format[B]implicit val jsonCFormat : Format[C] = Json.format[C]</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the “trick” now is to use the JsPath <a href="https://www.playframework.com/documentation/2.5.x/ScalaJsonCombinators">Play Json Combinator</a> for the embedded case classes without any path.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">import play.api.libs.functional.syntax._implicit val jsonExample2Format: Format[JsonExample2]  = (  (JsPath).format[A] and  (JsPath).format[B] and  (JsPath).format[C])(JsonExample2.apply, unlift(JsonExample2.unapply))</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s all folks!</p>
</div>
</div>
</div>]]></description><link>https://pepite.github.io/hubpress.io/2016/08/15/Play-Framework-Beginner-Tutorial-How-to-handle-a-big-json-file-in-play-more-than-22-root-variables.html</link><guid isPermaLink="true">https://pepite.github.io/hubpress.io/2016/08/15/Play-Framework-Beginner-Tutorial-How-to-handle-a-big-json-file-in-play-more-than-22-root-variables.html</guid><category><![CDATA[play]]></category><pubDate>Mon, 15 Aug 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Continuous Integration on GitLab with Scala and SBT]]></title><description><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>With Continuous Integration (CI) we aim to be able to test the changes we make to our projects automatically and externally. An usual setup involves e.g. GitHub and Jenkins and requires quite some configuration.</p>
</div>
<div class="paragraph">
<p>In this post we look at an alternative approach using GitLab which offers both the features of the aforementioned services: git hosting and continuous integration.</p>
</div>
<div class="paragraph">
<p>In this post we specifically focus on Scala projects with SBT as the build tool. Let’s assume we have an SBT project that contains tests and is hosted on GitLab. Now we have to tell GitLab that we want CI. We do this by adding a <code>.gitlab-cy.yml</code> file in the root directory of our project.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_code_gitlab_ci_yml_code_file">The <code>.gitlab-ci.yml</code> File</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Builds are run in Docker and therefore we have to specify in the .gitlab-ci.yml file which Docker image we want to use. Additionally we define some commands before our tests are run. We use the Java 8 image and make sure SBT is installed and available in our builds:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yml" data-lang="yml">image: java:8

before_script:
  # Enable the usage of sources over https
  - apt-get update -yqq
  - apt-get install apt-transport-https -yqq
  # Add keyserver for SBT
  - echo "deb http://dl.bintray.com/sbt/debian /" | tee -a /etc/apt/sources.list.d/sbt.list
  - apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 642AC823
  # Install SBT
  - apt-get update -yqq
  - apt-get install sbt -yqq
  # Log the sbt version
  - sbt sbt-version</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let’s define the stages we want to use. We add the test stage with the following lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yml" data-lang="yml">stages:
  - test</code></pre>
</div>
</div>
<div class="paragraph">
<p>At last, we define a job in the test stage that executes the the tests in our project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yml" data-lang="yml">test:
  stage: test
  script:
    # Execute your project's tests
    - sbt clean test</code></pre>
</div>
</div>
<div class="paragraph">
<p>Builds within the same stage run in parallel and the jobs in a next stage are started after all previous stages are successfully finished. We can define as much stages and builds as we want. Together, they are called a pipeline.</p>
</div>
<div class="paragraph">
<p>After we commit and push the <code>.gitlab-ci.yml</code> file to GitLab, CI is enabled and the pipeline is executed on every new push to the project.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_measuring_test_coverage">Measuring Test Coverage</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To display the test coverage of our test job we need to take two steps:</p>
</div>
<div class="paragraph">
<p>Add test coverage measuring in our SBT project.</p>
</div>
<div class="paragraph">
<p>Instruct GitLab how to extract the coverage percentage from the build trace.</p>
</div>
<div class="paragraph">
<p>We measure test coverage by using the SBT plugin sbt-scoverage. Add the following line to <code>/project/plugins.sbt</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yml" data-lang="yml">addSbtPlugin("org.scoverage" % "sbt-scoverage" % "1.3.5")</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can now measure test coverage with sbt clean coverage test coverageReport. We change this in <code>.gitlab-ci.yml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yml" data-lang="yml">test:
  stage: test
  script:
    # Execute your project's tests and measure test coverage
    - sbt clean coverage test coverageReport</code></pre>
</div>
</div>
<div class="paragraph">
<p>And in our project settings under CI/CD pipelines &gt; Test coverage parsing we add the following regular expression: Coverage was <code>\[\d+.\d+\%\]</code>. This enables GitLab to extract the coverage percentage from a build trace and display it next the the build results.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_source_code">Source Code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The source code of a demo SBT project implementing the steps described in this post can be found here:</p>
</div>
<div class="paragraph">
<p><a href="https://gitlab.com/jasperdenkers/lunatech-demo-ci-scala-sbt" class="bare">https://gitlab.com/jasperdenkers/lunatech-demo-ci-scala-sbt</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_s_next">What’s Next?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Next week we are going a step further and we implement continuous delivery (CD) in GitLab with the Play Framework and Heroku.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_references">References</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://docs.gitlab.com/ce/ci/" class="bare">http://docs.gitlab.com/ce/ci/</a></p>
</div>
</div>
</div>]]></description><link>https://pepite.github.io/hubpress.io/2016/08/01/Continuous-Integration-on-Git-Lab-with-Scala-and-SBT.html</link><guid isPermaLink="true">https://pepite.github.io/hubpress.io/2016/08/01/Continuous-Integration-on-Git-Lab-with-Scala-and-SBT.html</guid><category><![CDATA[gitlabs]]></category><category><![CDATA[git]]></category><category><![CDATA[CI]]></category><dc:creator><![CDATA[Nicolas Leroux]]></dc:creator><pubDate>Mon, 01 Aug 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Recursion and Trampolines in Scala]]></title><description><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Recursion is beautiful. As an example, let&#8217;s consider this perfectly acceptable example of defining the functions <code>even</code> and <code>odd</code> in Scala, whose semantics you can guess:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">def even(i: Int): Boolean = i match {
  case 0 =&gt; true
  case _ =&gt; odd(i - 1)
}

def odd(i: Int): Boolean = i match {
  case 0 =&gt; false
  case _ =&gt; even(i - 1)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve defined even in a very natural way: an value is <code>even</code> when it&#8217;s zero, or when it&#8217;s <code>odd</code> after subtracting one. <code>Odd</code> is defined in a similar way.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s ignore the problem this code has with negative integers, and the fact that an <code>O(n)</code> algorithm for computing <code>even</code> and <code>odd</code> is not ideal, and focus on a single problem: this code breaks for large n:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>scala&gt; even(5000)
res3: Boolean = true
scala&gt; even(50000)
java.lang.StackOverflowError
at Trampolines$Stack$.odd(trampolines.scala:14)
at Trampolines$Stack$.even(trampolines.scala:9)
at Trampolines$Stack$.odd(trampolines.scala:14)
at Trampolines$Stack$.even(trampolines.scala:9)
at Trampolines$Stack$.odd(trampolines.scala:14)
at Trampolines$Stack$.even(trampolines.scala:9)
...
at Trampolines$Stack$.even(trampolines.scala:9)
at Trampolines$Stack$.odd(trampolines.scala:14)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the remainder of this post we look at various strategies for preventing recursive programs from running out of memory.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_but_what_s_the_problem">But what&#8217;s the problem?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The problem manifests itself in the stack trace: even calls <code>odd</code>, then <code>odd</code> calls <code>even</code>, which calls <code>odd</code> again. Each of these invocations causes the creation of a stack frame, eating away the space that&#8217;s reserved for them.</p>
</div>
<div class="paragraph">
<p>Keeping all the stack frames would not really be necessary: when <code>even</code> calls <code>odd</code>, that is the very last thing that the even function will ever do! When <code>odd</code> returns, <code>even</code> itself returns immediately with that same value.</p>
</div>
<div class="paragraph">
<p>When we compute <code>even(500)</code>, after a bunch of recursive calls, the 501st stack frame will be created, for the invocation of <code>even(0)</code>, which returns true, and the 500 method calls that are left on the stack will one after another all return that same value, until the whole stack is unwinded.</p>
</div>
<div class="paragraph">
<p>Some languages or runtimes are smart enough to figure out that if a calling function will simply return the value that a function it calls returns, it does not need to allocate a new stack frame for the callee, but can reuse the stack frame of the caller for that.</p>
</div>
<div class="paragraph">
<p>Unfortunately, the JVM does not support this.</p>
</div>
<div class="paragraph">
<p>And so Scala, as long as it sticks to JVM method calling semantics, also can not support this.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_bit_of_light_at_the_end_of_the_tunnel">A bit of light at the end of the tunnel</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Luckily, there is one special case of tail calls which Scala treats differently, and that is the case of tail recursion. If a method does a tail call to itself, it&#8217;s called tail recursion, and Scala will rewrite the recursion into a loop that does not consume stack space.</p>
</div>
<div class="paragraph">
<p>Many recursive algorithms can be rewritten in a tail recursive way. For our even and odd problem, this is a possible solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">def even(i: Int): Boolean = i match {
case 0 =&gt; true
case 1 =&gt; false
case _ =&gt; even(i - 2)
}
def odd(i: Int): Boolean = !even(i)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve rewritten <code>even</code> to be tail-recursive, and now Scala will optimize it for us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>scala&gt; even(500000000)
res25: Boolean = true</code></pre>
</div>
</div>
<div class="paragraph">
<p>it no longer blows up for large numbers.</p>
</div>
<div class="paragraph">
<p>The <code>@tailrec</code> annotation is useful in these cases. It does not change how the function will be compiled, but it does trigger an error if the function is not actually tail-recursive. So this will protect you from accidentally changing a function that you want to be tail-recursive function into something that&#8217;s no longer tail recursive.</p>
</div>
<div class="paragraph">
<p>You can try this out by putting the <code>@tailrec</code> annotation on the first and the latest version of even that we&#8217;ve defined.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_trampolines">Trampolines</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Another way of solving the problem of consuming too much stack space, is by moving the computation from the stack to the heap.</p>
</div>
<div class="paragraph">
<p>Instead of letting the even function recursively call odd, we could also let it return some recipe to it&#8217;s caller, how to continue with the computation. Let&#8217;s look at the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">sealed trait EvenOdd

case class Done(result: Boolean) extends EvenOdd
case class Even(value: Int) extends EvenOdd
case class Odd(value: Int) extends EvenOdd

def even(i: Int): EvenOdd = i match {
  case 0 =&gt; Done(true)
  case _ =&gt; Odd(i - 1)
}

def odd(i: Int): EvenOdd = i match {
  case 0 =&gt; Done(false)
  case _ =&gt; Even(i - 1)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we defined a little language, EvenOdd, that can express three things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The computation is Done, and we have the result value</p>
</li>
<li>
<p>We need to compute whether a value is Even</p>
</li>
<li>
<p>We need to compute whether a value is Odd</p>
</li>
<li>
<p>Our even and odd functions no longer return a boolean, but return an expression in this little language.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, we create an interpreter, that will recursively evaluate expressions in this language:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// Using Scala's self recursive tail call optimization
@tailrec
def run(evenOdd: EvenOdd): Boolean = evenOdd match {
  case Done(result) =&gt; result
  case Even(value) =&gt; run(even(value))
  case Odd(value) =&gt; run(odd(value))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we have expressed <code>even</code> and <code>odd</code> in their natural, mutually recursive way, and we still have a stack safe interpreter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>scala&gt; run(even(5000000))
res1: Boolean = true</code></pre>
</div>
</div>
<div class="paragraph">
<p>The disadvantage of this is that this is significantly slower. Unfortunately, we can&#8217;t seem to have our cake and eat it too :(</p>
</div>
<div class="paragraph">
<p>This strategy is sometimes called trampolining, because instead of creating a big stack, we go up to <code>even</code>, then down to run, then up to <code>odd</code>, then down to run, then up to <code>even</code>, down to run, etcetera. The size of our stack keeps growing and shrinking by one frame for every step in the computation. This looks a lot like going up and down on a trampoline :)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_generalizing">Generalizing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There is no need to specialize our little language to computing <code>even</code> and <code>odd</code>. We can also make a little language that can express recursion in a general way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">sealed trait Computation[A]

class Continue[A](n: =&gt; Computation[A]) extends Computation[A] {
  lazy val next = n
}

case class Done[A](result: A) extends Computation[A]
  def even(i: Int): Computation[Boolean] = i match {
    case 0 =&gt; Done(true)
    case _ =&gt; new Continue(odd(i - 1))
  }

  def odd(i: Int): Computation[Boolean] = i match {
    case 0 =&gt; Done(false)
    case _ =&gt; new Continue(even(i - 1))
  }

  @tailrec
  def run[A](computation: Computation[A]): A = computation match {
    case Done(a) =&gt; a
    case c: Continue[A] =&gt; run(c.next)
  }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_recursion_and_trampolines_in_scala">Recursion and Trampolines in Scala</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Here our even and odd functions don&#8217;t return domain specific values, but a general value that indicates whether the computation is done, or whether more steps are needed. The latter includes the next step as a by-name parameter, that the tail recursive runner function can call.</p>
</div>
<div class="paragraph">
<p>Note that our run function is no longer tied to computing <code>even</code> and <code>odd</code>, it can compute anything.</p>
</div>
<div class="paragraph">
<p><code>TailRec</code> in the standard library</p>
</div>
<div class="paragraph">
<p>Something similar in spirit, but with a better implementation is also available in the Scala standard library:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">import scala.util.control.TailCalls.{ TailRec, done, tailcall }

def even(i: Int): TailRec[Boolean] = i match {
  case 0 =&gt; done(true)
  case _ =&gt; tailcall(odd(i - 1))
}

def odd(i: Int): TailRec[Boolean] = i match {
  case 0 =&gt; done(false)
  case _ =&gt; tailcall(even(i - 1))
}

even(3000).result</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comparing_performance">Comparing performance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I compared the performance of these solutions with JMH, and these are the results:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[info] Benchmark Mode Cnt Score Error Units
[info] Trampolines.GeneralTrampolineRunner.bench thrpt 30 44916.024 ± 388.202 ops/s
[info] Trampolines.ScalaTrampolineRunner.bench thrpt 30 52106.426 ± 408.242 ops/s
[info] Trampolines.SpecializedTrampolineRunner.bench thrpt 30 94002.234 ± 1584.913 ops/s
[info] Trampolines.StackRunner.bench thrpt 30 358382.321 ± 6622.659 ops/s</code></pre>
</div>
</div>
<div class="paragraph">
<p>As expected, the version that runs on the stack is the fastest. But remember that this is the version that breaks for a large number of recursions.</p>
</div>
<div class="paragraph">
<p>The specialized trampolining version, with the <code>EvenOdd</code> domain specific language and a runner optimized for this particular problem, takes about a 4 times speed hit compared to the stack version.</p>
</div>
<div class="paragraph">
<p>The general trampoline version that we defined here is about 2 times slower than the specialized version, and about 8 times slower than the stack version.</p>
</div>
<div class="paragraph">
<p>The <code>TailRec</code> version from the Scala standard library is about 20% faster than our general trampoline, making it about 7 times slower than the stack version.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_source_code">Source code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The source code of the benchmarks (and all the code), is available on <a href="https://github.com/eamelink/scala-trampolines" class="bare">https://github.com/eamelink/scala-trampolines</a></p>
</div>
</div>
</div>]]></description><link>https://pepite.github.io/hubpress.io/2016/07/15/Recursion-and-Trampolines-in-Scala.html</link><guid isPermaLink="true">https://pepite.github.io/hubpress.io/2016/07/15/Recursion-and-Trampolines-in-Scala.html</guid><category><![CDATA[scala]]></category><category><![CDATA[recursion]]></category><category><![CDATA[fp]]></category><dc:creator><![CDATA[Nicolas Leroux]]></dc:creator><pubDate>Fri, 15 Jul 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Clever Cloud’s CEO to speak at Lunatech]]></title><description><![CDATA[<div class="paragraph">
<p>Friday 27 May 2016 Clever Cloud’s CEO, <strong>Quentin Adam</strong>, will be visiting Lunatech where he will give a presentation about using Clever Cloud with Scala.</p>
</div>
<div class="paragraph">
<p>Clever Cloud is a “Europe-based PaaS company” that helps “developers deploy and run their apps with bulletproof infrastructure, automatic scaling, fair pricing” and aims “to make an easy-to-use service, without any vendor lock-in”.</p>
</div>
<div class="paragraph">
<p>Due to his experience at Clever Cloud — where he can work a wide range of technologies and tools — he has a lot of knowledge and is able to speak about many different subjects. He regularly speaks at various tech conferences.</p>
</div>
<div class="paragraph">
<p>We are opening up the presentation to everyone. Feel free to join us at 16:00.</p>
</div>]]></description><link>https://pepite.github.io/hubpress.io/2016/05/26/Clever-Clouds-CEO-to-speak-at-Lunatech.html</link><guid isPermaLink="true">https://pepite.github.io/hubpress.io/2016/05/26/Clever-Clouds-CEO-to-speak-at-Lunatech.html</guid><category><![CDATA[company]]></category><pubDate>Thu, 26 May 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Scala training camp at Lunatech]]></title><description><![CDATA[<div class="paragraph">
<p>Every friday our teams work together to improve their skills on Scala and other technologies. They explore new grounds, new ideas and new techniques.  They share knowledge between teams. Join us if you want to make your passion your work.</p>
</div>]]></description><link>https://pepite.github.io/hubpress.io/2016/05/19/Scala-training-camp-at-Lunatech.html</link><guid isPermaLink="true">https://pepite.github.io/hubpress.io/2016/05/19/Scala-training-camp-at-Lunatech.html</guid><category><![CDATA[scala]]></category><category><![CDATA[office]]></category><pubDate>Thu, 19 May 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[On the road again: Scala days Berlin 2016]]></title><description><![CDATA[<div class="paragraph">
<p>Lunatech is proud to present the real star of this event: the Lunatech carry-on suitcase. With its class and convenience, it will accompany all Lunatech employees to the 2016 Scala days in Berlin. All suitcases are personalised with their owner’s name to make it difficult to sell them to the highest bidder and to prevent people ending up with their colleague’s suitcase.</p>
</div>]]></description><link>https://pepite.github.io/hubpress.io/2016/05/16/On-the-road-again-Scala-days-Berlin-2016.html</link><guid isPermaLink="true">https://pepite.github.io/hubpress.io/2016/05/16/On-the-road-again-Scala-days-Berlin-2016.html</guid><category><![CDATA[scaladays]]></category><pubDate>Mon, 16 May 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Platinum sponsor of Scala Days Berlin]]></title><description><![CDATA[<div class="paragraph">
<p>Lunatech is proud to be a <a href="http://event.scaladays.org/scaladays-berlin-2016#05-Sponsors">platinum sponsor for Scala Days Berlin 2016</a>. This year Lunatech is taking the whole team to Scala Days Berlin.</p>
</div>
<div class="paragraph">
<p>If you’re there and are looking for a job with the kind of company that sponsors and takes all its employees to Scala Days, have a chat with us, there’ll be a lot of us walking around. If you can’t wait, get in touch with us right now.</p>
</div>]]></description><link>https://pepite.github.io/hubpress.io/2016/04/14/Platinum-sponsor-of-Scala-Days-Berlin.html</link><guid isPermaLink="true">https://pepite.github.io/hubpress.io/2016/04/14/Platinum-sponsor-of-Scala-Days-Berlin.html</guid><category><![CDATA[scaladays]]></category><pubDate>Thu, 14 Apr 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Fast Track to Scala Training by Lunatech]]></title><description><![CDATA[<div class="paragraph">
<p>On Feb 4 and 5th <strong>Francisco Canedo</strong>, Senior Developer at Lunatech and a Typesafe certified trainer, will be teaching Typesafe’s Fast Track to Scala Course at our office.</p>
</div>
<div class="paragraph">
<p>This course is designed to give experienced developers the know-how to confidently start programming in Scala. The course ensures you will have a solid understanding of the fundamentals of the language, the tooling and the development process as well as a good appreciation of the more advanced features. If you already have Scala programming experience, then this course could be a useful refresher, yet no previous knowledge of Scala is assumed.</p>
</div>
<div class="paragraph">
<p>The course starts each day at 9:00 with breakfast, lunch is also provided, and ends between 17:00 and 18:00 depending on the needs of the students and costs €600 per person.</p>
</div>
<div class="paragraph">
<p>If you are interested in joining the course, please contact us by sending a mail to <a href="mailto:training@lunatech.com">training@lunatech.com</a> or tweet us @LunatechLabs</p>
</div>]]></description><link>https://pepite.github.io/hubpress.io/2016/01/18/Fast-Track-to-Scala-Training-by-Lunatech.html</link><guid isPermaLink="true">https://pepite.github.io/hubpress.io/2016/01/18/Fast-Track-to-Scala-Training-by-Lunatech.html</guid><category><![CDATA[scala]]></category><pubDate>Mon, 18 Jan 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Our first award!]]></title><description><![CDATA[<div class="paragraph">
<p>Lunatech has been awarded by the “<em>The National Business Success Award Institute</em>” as branch winner 2015 in the category “ICT”.</p>
</div>
<div class="paragraph">
<p>The jury cited the company&#8217;s service quality, technology excellence and innovation. Representatives of the award winner also make appearances on the RTL television show "<em>De Success Factor</em>" .</p>
</div>]]></description><link>https://pepite.github.io/hubpress.io/2016/01/04/Our-first-award.html</link><guid isPermaLink="true">https://pepite.github.io/hubpress.io/2016/01/04/Our-first-award.html</guid><category><![CDATA[company]]></category><pubDate>Mon, 04 Jan 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Functional Rotterdam - 5th Edition]]></title><description><![CDATA[<div class="paragraph">
<p>Every first Tuesday of the month, at Lunatech we are organize a meetup focussed on Functional Programming. Tomorrow is the 5th edition of the event. You can join the fun by going to our <a href="http://www.meetup.com/Functional-Rotterdam/">meetup page</a></p>
</div>
<div class="paragraph">
<p>This is an informal event where we share our experience of using functional programing in our projects and learn from others who work in different languages. In the past we had presenations about Scala, Spark, Elm, Frege apart from a coding dojo at the last event.</p>
</div>
<div class="paragraph">
<p>Do join us by RSVPing on the <a href="http://www.meetup.com/Functional-Rotterdam/">meetup page</a></p>
</div>]]></description><link>https://pepite.github.io/hubpress.io/2016/01/04/Functional-Rotterdam-5th-Edition.html</link><guid isPermaLink="true">https://pepite.github.io/hubpress.io/2016/01/04/Functional-Rotterdam-5th-Edition.html</guid><category><![CDATA[fp]]></category><pubDate>Mon, 04 Jan 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Lunatech management realises MBO]]></title><description><![CDATA[<div class="paragraph">
<p><strong>Ray Kemp</strong> and <strong>Nicolas Leroux</strong>, jointly CEO, have successfully realized a management buy-out (“MBO”) of Lunatech Labs BV (“Lunatech”). Also, some staff members acquired a small stake in the company in this transaction. Lunatech is a Dutch IT service provider specialised in system integration, customised software implementation and web applications.</p>
</div>
<div class="paragraph">
<p>Main Corporate Finance has structured the MBO and arranged the debt financing. Bank financing has been provided by Rabobank. The transaction was partly financed with a mezzanine loan provided by Main Mezzanine Capital.Lunatech stands out in linking and structuring applications between back-end and front-end. Lunatech provides support for complex IT system integration and migration projects and they support IT departments of organisations. The company offers high quality solutions including consultancy and supplying project teams of Scala professionals.</p>
</div>
<div class="paragraph">
<p>Lunatech was founded in 1993 and located in Rotterdam. Lunatech provides its services to proven customers in the Netherlands and France, as for example: ING, SDU, Alcatel, Disney and UPS.</p>
</div>
<div class="paragraph">
<p>The strength of Lunatech is also recognised by the investors, says Lars van ‘t Hoenderdaal: “<em>Lunatech is a very nice company with a strong management team and international growth potential. We experienced great interest among our funders to participate in this mezzanine proposition</em>.”</p>
</div>
<div class="paragraph">
<p>After reaching agreement on the transaction structure and financing structure, the transaction has been completed within 4 weeks. Rabobank has also shown their strength by acting quickly.</p>
</div>
<div class="paragraph">
<p>Ray Kemp, CEO Lunatech, is very satisfied with the realised MBO: <em>“Due to funding from the bank and mezzanine we were able to realise the MBO without a private equity investor. In this way we can realise our growth independently</em>.”</p>
</div>
<div class="paragraph">
<p>Main Mezzanine Capital is part of Main Capital Partners, an investment and financing company, as well as a corporate finance advisor, with a focus on growing and profitable companies in the TMT sector in the Netherlands. Main Mezzanine Capital is funded by its own shareholders, wealthy individuals, family offices and (former) entrepreneurs, who like to invest in companies with an interesting risk-return profile.</p>
</div>]]></description><link>https://pepite.github.io/hubpress.io/2015/12/22/Lunatech-management-realises-MBO.html</link><guid isPermaLink="true">https://pepite.github.io/hubpress.io/2015/12/22/Lunatech-management-realises-MBO.html</guid><category><![CDATA[company]]></category><pubDate>Tue, 22 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Syntactically correct and type-safe JPA queries in Play 2.0]]></title><description><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>For all three approaches we’ll use the same use case: find a <code>User</code> object by its ‘username’ property.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_java_persistence_api_query_language">Java Persistence API query language</h3>
<div class="paragraph">
<p>An easy way to read data from our database is by creating a ‘dynamic query’ with use of the Java Persistance API (JPA) query language, a string-based query language. To find a <code>User</code> by username we would write something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
    return JPA.em()
        .createQuery("from User where username = :username", User.class)
        .setParameter("username", "foo").getSingleResult();
} catch (NoResultException nre) {
    return null;
} catch (NonUniqueResultException nure) {
    return null;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem with this example is syntax checking. The query language is not checked at compile time, so if we write <code>from Uzer</code> instead of <code>from User</code> no compile-time errors will occur. However, because the query is incorrect, we &lt;em&gt;will&lt;/em&gt; get a runtime error. To prevent these kind of runtime errors we need a way to create syntactically checked queries. This is where the JPA Criteria API comes in.</p>
</div>
</div>
<div class="sect2">
<h3 id="_jpa_criteria_api">JPA Criteria API</h3>
<div class="paragraph">
<p>The Criteria API is an alternative to the query language. It allows us to define object-based queries instead of the string-based approach of the query language. The advantage is that these object-based queries are more syntactically checked.</p>
</div>
<div class="paragraph">
<p>If we want to find the <code>User</code> with help of the Criteria API it becomes this piece of code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
    CriteriaBuilder cb = JPA.em().getCriteriaBuilder();
    CriteriaQuery&lt;User&gt; query = cb.createQuery(User.class);
    Root&lt;User&gt; user = query.from(User.class);
    query.where(cb.equal(user.get("username"), "foo"));
    return JPA.em().createQuery(query).getSingleResult();
} catch (NoResultException nre) {
    return null;
} catch (NonUniqueResultException nure) {
    return null;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the compiler will give us an error if we write <code>Uzer.class</code> instead of <code>User.class</code>. So more syntax checking. But as you probably already noticed, <code>user.get("username")</code> is still not checked for correct syntax. Our code will successfully compile if we replace <code>username</code> with <code>uzrname</code>. This is because the compiler doesn’t know if <code>uzrname</code> is a property of the <code>User</code> class. So we need more syntax checking to prevent these kind of errors. With the help of Java Persistence Metamodel API we can create fully syntactically checked queries.</p>
</div>
</div>
<div class="sect2">
<h3 id="_jpa_2_0_metamodels">JPA 2.0 Metamodels</h3>
<div class="paragraph">
<p>A metamodel class is a class that represents the datastructure of the corresponding model class. For example, this model class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Entity
public class User {
    public Long id;
    public String username;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Would have the following metamodel class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@StaticMetamodel(User.class)
public abstract class User_ {
    public static volatile SingularAttribute&lt;User, String&gt; username;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we are able to create a type-safe query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
    CriteriaBuilder cb = JPA.em().getCriteriaBuilder();
    CriteriaQuery&amp;lt;User&amp;gt; query = cb.createQuery(User.class);
    Root&amp;lt;User&amp;gt; user = query.from(User.class);
    query.where(cb.equal(user.get(User_.username), "foo"));
    return JPA.em().createQuery(query).getSingleResult();
} catch (NoResultException nre) {
    return null;
} catch (NonUniqueResultException nure) {
    return null;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>These metamodels are pretty useful because our queries are syntactically correct and type-safe&#33; Syntactically correct because all the syntax is checked. We will get an error is we replace <code>username</code> by <code>uzername</code>. So if we, for example, rename a variable, the compiler will tell us which queries we forgot to update. We won’t get a runtime error.</p>
</div>
<div class="paragraph">
<p>The query is also type-safe. Type safety means that the compiler will validate types while compiling. If a wrong type is assigned to a variable an exception is thrown at compile time. As you probably know Play 2.0 is [focused on type safety](<a href="http://www.playframework.org/documentation/2.0/Philosophy" class="bare">http://www.playframework.org/documentation/2.0/Philosophy</a>).</p>
</div>
<div class="paragraph">
<p>Because of the metamodels, the compiler knows the type of the variables. So you can’t for example do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
    CriteriaBuilder cb = JPA.em().getCriteriaBuilder();
    CriteriaQuery&amp;lt;User&amp;gt; query = cb.createQuery(User.class);
    Root&amp;lt;User&amp;gt; user = query.from(User.class);
    query.like(cb.like(user.get(User_.id), "1"));
    return JPA.em().createQuery(query).getSingleResult();
} catch (NoResultException nre) {
    return null;
} catch (NonUniqueResultException nure) {
    return null;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This query won’t compile because the <code>like</code> method needs a <code>Expression&lt;String&gt;</code> as first parameter and <code>id</code> is a <code>Expression&lt;Long&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Because it takes some time to write these metamodels by hand, it would be nicer to generate them. The next paragraph will explain how to generate metamodels in Play 2.0.</p>
</div>
</div>
<div class="sect2">
<h3 id="_jpa_2_0_metamodel_genaration_in_play_2_0">JPA 2.0 Metamodel genaration in Play 2.0</h3>
<div class="paragraph">
<p>A way to generate our metamodels is by using the <code>org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor</code>. The processor will automatically run if the hibernate-jpamodelgen.jar is added to the classpath and when you are using JDK 6. So we add a project dependecy to our Build.scala:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">val appDependencies = Seq(
    "org.hibernate" % "hibernate-jpamodelgen" % "1.2.0.Final"
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And specify a folder where the generated source files are placed. This is done by passing an argument to the Java compiler. Passing an argument is also done in Build.scala:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">val main = PlayProject(appName, appVersion, appDependencies, mainLang = JAVA).settings(
    javacOptions ++= Seq("-s", "metamodel")
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the provided folder must exist, the Java compiler won’t generate it for you. So it is probably not a good idea to put the metamodels in our target folder, because its contents are deleted when the the <code>play clean</code> command is run.</p>
</div>
<div class="paragraph">
<p>Eclipse users can add the metamodel folder to their ‘source folders’ (Project → Properties → Java Build Path → Source → Add Folder) for autocompletion etc.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion">Conclusion</h3>
<div class="paragraph">
<p>Using the Criteria API with metamodels gives us the opportunity to write syntactically correct and type-safe queries. It is also quite easy to generate these metamodels. So with a bit of effort we can get nice object-based, syntactically correct and type-safe queries that cause fewer runtime errors.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sources">Sources</h3>
<div class="paragraph">
<p>[JSR-317 - Java Persistence 2.0](<a href="http://jcp.org/aboutJava/communityprocess/final/jsr317/" class="bare">http://jcp.org/aboutJava/communityprocess/final/jsr317/</a>)</p>
</div>
<div class="paragraph">
<p>[Hibernate JPA 2 Metamodel Generator](<a href="http://docs.jboss.org/hibernate/jpamodelgen/1.0/reference/en-US/html_single" class="bare">http://docs.jboss.org/hibernate/jpamodelgen/1.0/reference/en-US/html_single</a>)</p>
</div>
</div>]]></description><link>https://pepite.github.io/hubpress.io/2015/07/15/Syntactically-correct-and-type-safe-JPA-queries-in-Play-20.html</link><guid isPermaLink="true">https://pepite.github.io/hubpress.io/2015/07/15/Syntactically-correct-and-type-safe-JPA-queries-in-Play-20.html</guid><category><![CDATA[scala]]></category><category><![CDATA[recursion]]></category><category><![CDATA[fp]]></category><pubDate>Wed, 15 Jul 2015 00:00:00 GMT</pubDate></item></channel></rss>