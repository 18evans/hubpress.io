<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Lunatech's engineer blog]]></title><description><![CDATA[FP, Scala and Java]]></description><link>https://pepite.github.io/hubpress.io</link><generator>RSS for Node</generator><lastBuildDate>Thu, 05 Jan 2017 13:52:15 GMT</lastBuildDate><atom:link href="https://pepite.github.io/hubpress.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[my second post]]></title><description><![CDATA[<div class="paragraph">
<p>This is a post and this is ok. This is scala code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">val x = 1

def toDays(hours: Float) = if (hours &gt; 0) Math.ceil((hours / 8) * 4).toFloat / 4f else 0f

def totalBillableHours = {
  entries.filter(_.billable).map( time =&gt; TimeUtil.toHours(time.duration.getStandardSeconds)).sum
}

def totalHours = {
  entries.map( time =&gt; TimeUtil.toHours(time.duration.getStandardSeconds)).sum
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>bla <strong>bla</strong>. Is syntax highlighting working?# My first post</p>
</div>
<div class="paragraph">
<p>This is a post and this is ok. This is scala code:</p>
</div>]]></description><link>https://pepite.github.io/hubpress.io/2016/12/11/my-second-post.html</link><guid isPermaLink="true">https://pepite.github.io/hubpress.io/2016/12/11/my-second-post.html</guid><dc:creator><![CDATA[Nicolas Leroux]]></dc:creator><pubDate>Sun, 11 Dec 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Recursion and Trampolines in Scala]]></title><description><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Recursion is beautiful. As an example, let&#8217;s consider this perfectly acceptable example of defining the functions <code>even</code> and <code>odd</code> in Scala, whose semantics you can guess:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">def even(i: Int): Boolean = i match {
  case 0 =&gt; true
  case _ =&gt; odd(i - 1)
}

def odd(i: Int): Boolean = i match {
  case 0 =&gt; false
  case _ =&gt; even(i - 1)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve defined even in a very natural way: an value is <code>even</code> when it&#8217;s zero, or when it&#8217;s <code>odd</code> after subtracting one. <code>Odd</code> is defined in a similar way.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s ignore the problem this code has with negative integers, and the fact that an <code>O(n)</code> algorithm for computing <code>even</code> and <code>odd</code> is not ideal, and focus on a single problem: this code breaks for large n:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>scala&gt; even(5000)
res3: Boolean = true
scala&gt; even(50000)
java.lang.StackOverflowError
at Trampolines$Stack$.odd(trampolines.scala:14)
at Trampolines$Stack$.even(trampolines.scala:9)
at Trampolines$Stack$.odd(trampolines.scala:14)
at Trampolines$Stack$.even(trampolines.scala:9)
at Trampolines$Stack$.odd(trampolines.scala:14)
at Trampolines$Stack$.even(trampolines.scala:9)
...
at Trampolines$Stack$.even(trampolines.scala:9)
at Trampolines$Stack$.odd(trampolines.scala:14)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the remainder of this post we look at various strategies for preventing recursive programs from running out of memory.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_but_what_s_the_problem">But what&#8217;s the problem?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The problem manifests itself in the stack trace: even calls <code>odd</code>, then <code>odd</code> calls <code>even</code>, which calls <code>odd</code> again. Each of these invocations causes the creation of a stack frame, eating away the space that&#8217;s reserved for them.</p>
</div>
<div class="paragraph">
<p>Keeping all the stack frames would not really be necessary: when <code>even</code> calls <code>odd</code>, that is the very last thing that the even function will ever do! When <code>odd</code> returns, <code>even</code> itself returns immediately with that same value.</p>
</div>
<div class="paragraph">
<p>When we compute <code>even(500)</code>, after a bunch of recursive calls, the 501st stack frame will be created, for the invocation of <code>even(0)</code>, which returns true, and the 500 method calls that are left on the stack will one after another all return that same value, until the whole stack is unwinded.</p>
</div>
<div class="paragraph">
<p>Some languages or runtimes are smart enough to figure out that if a calling function will simply return the value that a function it calls returns, it does not need to allocate a new stack frame for the callee, but can reuse the stack frame of the caller for that.</p>
</div>
<div class="paragraph">
<p>Unfortunately, the JVM does not support this.</p>
</div>
<div class="paragraph">
<p>And so Scala, as long as it sticks to JVM method calling semantics, also can not support this.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_bit_of_light_at_the_end_of_the_tunnel">A bit of light at the end of the tunnel</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Luckily, there is one special case of tail calls which Scala treats differently, and that is the case of tail recursion. If a method does a tail call to itself, it&#8217;s called tail recursion, and Scala will rewrite the recursion into a loop that does not consume stack space.</p>
</div>
<div class="paragraph">
<p>Many recursive algorithms can be rewritten in a tail recursive way. For our even and odd problem, this is a possible solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">def even(i: Int): Boolean = i match {
case 0 =&gt; true
case 1 =&gt; false
case _ =&gt; even(i - 2)
}
def odd(i: Int): Boolean = !even(i)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve rewritten <code>even</code> to be tail-recursive, and now Scala will optimize it for us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>scala&gt; even(500000000)
res25: Boolean = true</code></pre>
</div>
</div>
<div class="paragraph">
<p>it no longer blows up for large numbers.</p>
</div>
<div class="paragraph">
<p>The <code>@tailrec</code> annotation is useful in these cases. It does not change how the function will be compiled, but it does trigger an error if the function is not actually tail-recursive. So this will protect you from accidentally changing a function that you want to be tail-recursive function into something that&#8217;s no longer tail recursive.</p>
</div>
<div class="paragraph">
<p>You can try this out by putting the <code>@tailrec</code> annotation on the first and the latest version of even that we&#8217;ve defined.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_trampolines">Trampolines</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Another way of solving the problem of consuming too much stack space, is by moving the computation from the stack to the heap.</p>
</div>
<div class="paragraph">
<p>Instead of letting the even function recursively call odd, we could also let it return some recipe to it&#8217;s caller, how to continue with the computation. Let&#8217;s look at the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">sealed trait EvenOdd

case class Done(result: Boolean) extends EvenOdd
case class Even(value: Int) extends EvenOdd
case class Odd(value: Int) extends EvenOdd

def even(i: Int): EvenOdd = i match {
  case 0 =&gt; Done(true)
  case _ =&gt; Odd(i - 1)
}

def odd(i: Int): EvenOdd = i match {
  case 0 =&gt; Done(false)
  case _ =&gt; Even(i - 1)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we defined a little language, EvenOdd, that can express three things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The computation is Done, and we have the result value</p>
</li>
<li>
<p>We need to compute whether a value is Even</p>
</li>
<li>
<p>We need to compute whether a value is Odd</p>
</li>
<li>
<p>Our even and odd functions no longer return a boolean, but return an expression in this little language.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, we create an interpreter, that will recursively evaluate expressions in this language:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// Using Scala's self recursive tail call optimization
@tailrec
def run(evenOdd: EvenOdd): Boolean = evenOdd match {
  case Done(result) =&gt; result
  case Even(value) =&gt; run(even(value))
  case Odd(value) =&gt; run(odd(value))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we have expressed <code>even</code> and <code>odd</code> in their natural, mutually recursive way, and we still have a stack safe interpreter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>scala&gt; run(even(5000000))
res1: Boolean = true</code></pre>
</div>
</div>
<div class="paragraph">
<p>The disadvantage of this is that this is significantly slower. Unfortunately, we can&#8217;t seem to have our cake and eat it too :(</p>
</div>
<div class="paragraph">
<p>This strategy is sometimes called trampolining, because instead of creating a big stack, we go up to <code>even</code>, then down to run, then up to <code>odd</code>, then down to run, then up to <code>even</code>, down to run, etcetera. The size of our stack keeps growing and shrinking by one frame for every step in the computation. This looks a lot like going up and down on a trampoline :)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_generalizing">Generalizing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There is no need to specialize our little language to computing <code>even</code> and <code>odd</code>. We can also make a little language that can express recursion in a general way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">sealed trait Computation[A]

class Continue[A](n: =&gt; Computation[A]) extends Computation[A] {
  lazy val next = n
}

case class Done[A](result: A) extends Computation[A]
  def even(i: Int): Computation[Boolean] = i match {
    case 0 =&gt; Done(true)
    case _ =&gt; new Continue(odd(i - 1))
  }

  def odd(i: Int): Computation[Boolean] = i match {
    case 0 =&gt; Done(false)
    case _ =&gt; new Continue(even(i - 1))
  }

  @tailrec
  def run[A](computation: Computation[A]): A = computation match {
    case Done(a) =&gt; a
    case c: Continue[A] =&gt; run(c.next)
  }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_recursion_and_trampolines_in_scala">Recursion and Trampolines in Scala</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Here our even and odd functions don&#8217;t return domain specific values, but a general value that indicates whether the computation is done, or whether more steps are needed. The latter includes the next step as a by-name parameter, that the tail recursive runner function can call.</p>
</div>
<div class="paragraph">
<p>Note that our run function is no longer tied to computing <code>even</code> and <code>odd</code>, it can compute anything.</p>
</div>
<div class="paragraph">
<p><code>TailRec</code> in the standard library</p>
</div>
<div class="paragraph">
<p>Something similar in spirit, but with a better implementation is also available in the Scala standard library:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">import scala.util.control.TailCalls.{ TailRec, done, tailcall }

def even(i: Int): TailRec[Boolean] = i match {
  case 0 =&gt; done(true)
  case _ =&gt; tailcall(odd(i - 1))
}

def odd(i: Int): TailRec[Boolean] = i match {
  case 0 =&gt; done(false)
  case _ =&gt; tailcall(even(i - 1))
}

even(3000).result</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comparing_performance">Comparing performance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I compared the performance of these solutions with JMH, and these are the results:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[info] Benchmark Mode Cnt Score Error Units
[info] Trampolines.GeneralTrampolineRunner.bench thrpt 30 44916.024 ± 388.202 ops/s
[info] Trampolines.ScalaTrampolineRunner.bench thrpt 30 52106.426 ± 408.242 ops/s
[info] Trampolines.SpecializedTrampolineRunner.bench thrpt 30 94002.234 ± 1584.913 ops/s
[info] Trampolines.StackRunner.bench thrpt 30 358382.321 ± 6622.659 ops/s</code></pre>
</div>
</div>
<div class="paragraph">
<p>As expected, the version that runs on the stack is the fastest. But remember that this is the version that breaks for a large number of recursions.</p>
</div>
<div class="paragraph">
<p>The specialized trampolining version, with the <code>EvenOdd</code> domain specific language and a runner optimized for this particular problem, takes about a 4 times speed hit compared to the stack version.</p>
</div>
<div class="paragraph">
<p>The general trampoline version that we defined here is about 2 times slower than the specialized version, and about 8 times slower than the stack version.</p>
</div>
<div class="paragraph">
<p>The <code>TailRec</code> version from the Scala standard library is about 20% faster than our general trampoline, making it about 7 times slower than the stack version.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_source_code">Source code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The source code of the benchmarks (and all the code), is available on <a href="https://github.com/eamelink/scala-trampolines" class="bare">https://github.com/eamelink/scala-trampolines</a></p>
</div>
</div>
</div>]]></description><link>https://pepite.github.io/hubpress.io/2016/12/11/Recursion-and-Trampolines-in-Scala.html</link><guid isPermaLink="true">https://pepite.github.io/hubpress.io/2016/12/11/Recursion-and-Trampolines-in-Scala.html</guid><dc:creator><![CDATA[Nicolas Leroux]]></dc:creator><pubDate>Sun, 11 Dec 2016 00:00:00 GMT</pubDate></item></channel></rss>